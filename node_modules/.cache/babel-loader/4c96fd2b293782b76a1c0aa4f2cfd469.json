{"ast":null,"code":"ace.define(\"ace/mode/asciidoc_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n  var AsciidocHighlightRules = function AsciidocHighlightRules() {\n    var identifierRe = \"[a-zA-Z\\xA1-\\uFFFF]+\\\\b\";\n    this.$rules = {\n      \"start\": [{\n        token: \"empty\",\n        regex: /$/\n      }, {\n        token: \"literal\",\n        regex: /^\\.{4,}\\s*$/,\n        next: \"listingBlock\"\n      }, {\n        token: \"literal\",\n        regex: /^-{4,}\\s*$/,\n        next: \"literalBlock\"\n      }, {\n        token: \"string\",\n        regex: /^\\+{4,}\\s*$/,\n        next: \"passthroughBlock\"\n      }, {\n        token: \"keyword\",\n        regex: /^={4,}\\s*$/\n      }, {\n        token: \"text\",\n        regex: /^\\s*$/\n      }, {\n        token: \"empty\",\n        regex: \"\",\n        next: \"dissallowDelimitedBlock\"\n      }],\n      \"dissallowDelimitedBlock\": [{\n        include: \"paragraphEnd\"\n      }, {\n        token: \"comment\",\n        regex: '^//.+$'\n      }, {\n        token: \"keyword\",\n        regex: \"^(?:NOTE|TIP|IMPORTANT|WARNING|CAUTION):\"\n      }, {\n        include: \"listStart\"\n      }, {\n        token: \"literal\",\n        regex: /^\\s+.+$/,\n        next: \"indentedBlock\"\n      }, {\n        token: \"empty\",\n        regex: \"\",\n        next: \"text\"\n      }],\n      \"paragraphEnd\": [{\n        token: \"doc.comment\",\n        regex: /^\\/{4,}\\s*$/,\n        next: \"commentBlock\"\n      }, {\n        token: \"tableBlock\",\n        regex: /^\\s*[|!]=+\\s*$/,\n        next: \"tableBlock\"\n      }, {\n        token: \"keyword\",\n        regex: /^(?:--|''')\\s*$/,\n        next: \"start\"\n      }, {\n        token: \"option\",\n        regex: /^\\[.*\\]\\s*$/,\n        next: \"start\"\n      }, {\n        token: \"pageBreak\",\n        regex: /^>{3,}$/,\n        next: \"start\"\n      }, {\n        token: \"literal\",\n        regex: /^\\.{4,}\\s*$/,\n        next: \"listingBlock\"\n      }, {\n        token: \"titleUnderline\",\n        regex: /^(?:={2,}|-{2,}|~{2,}|\\^{2,}|\\+{2,})\\s*$/,\n        next: \"start\"\n      }, {\n        token: \"singleLineTitle\",\n        regex: /^={1,5}\\s+\\S.*$/,\n        next: \"start\"\n      }, {\n        token: \"otherBlock\",\n        regex: /^(?:\\*{2,}|_{2,})\\s*$/,\n        next: \"start\"\n      }, {\n        token: \"optionalTitle\",\n        regex: /^\\.[^.\\s].+$/,\n        next: \"start\"\n      }],\n      \"listStart\": [{\n        token: \"keyword\",\n        regex: /^\\s*(?:\\d+\\.|[a-zA-Z]\\.|[ixvmIXVM]+\\)|\\*{1,5}|-|\\.{1,5})\\s/,\n        next: \"listText\"\n      }, {\n        token: \"meta.tag\",\n        regex: /^.+(?::{2,4}|;;)(?: |$)/,\n        next: \"listText\"\n      }, {\n        token: \"support.function.list.callout\",\n        regex: /^(?:<\\d+>|\\d+>|>) /,\n        next: \"text\"\n      }, {\n        token: \"keyword\",\n        regex: /^\\+\\s*$/,\n        next: \"start\"\n      }],\n      \"text\": [{\n        token: [\"link\", \"variable.language\"],\n        regex: /((?:https?:\\/\\/|ftp:\\/\\/|file:\\/\\/|mailto:|callto:)[^\\s\\[]+)(\\[.*?\\])/\n      }, {\n        token: \"link\",\n        regex: /(?:https?:\\/\\/|ftp:\\/\\/|file:\\/\\/|mailto:|callto:)[^\\s\\[]+/\n      }, {\n        token: \"link\",\n        regex: /\\b[\\w\\.\\/\\-]+@[\\w\\.\\/\\-]+\\b/\n      }, {\n        include: \"macros\"\n      }, {\n        include: \"paragraphEnd\"\n      }, {\n        token: \"literal\",\n        regex: /\\+{3,}/,\n        next: \"smallPassthrough\"\n      }, {\n        token: \"escape\",\n        regex: /\\((?:C|TM|R)\\)|\\.{3}|->|<-|=>|<=|&#(?:\\d+|x[a-fA-F\\d]+);|(?: |^)--(?=\\s+\\S)/\n      }, {\n        token: \"escape\",\n        regex: /\\\\[_*'`+#]|\\\\{2}[_*'`+#]{2}/\n      }, {\n        token: \"keyword\",\n        regex: /\\s\\+$/\n      }, {\n        token: \"text\",\n        regex: identifierRe\n      }, {\n        token: [\"keyword\", \"string\", \"keyword\"],\n        regex: /(<<[\\w\\d\\-$]+,)(.*?)(>>|$)/\n      }, {\n        token: \"keyword\",\n        regex: /<<[\\w\\d\\-$]+,?|>>/\n      }, {\n        token: \"constant.character\",\n        regex: /\\({2,3}.*?\\){2,3}/\n      }, {\n        token: \"keyword\",\n        regex: /\\[\\[.+?\\]\\]/\n      }, {\n        token: \"support\",\n        regex: /^\\[{3}[\\w\\d =\\-]+\\]{3}/\n      }, {\n        include: \"quotes\"\n      }, {\n        token: \"empty\",\n        regex: /^\\s*$/,\n        next: \"start\"\n      }],\n      \"listText\": [{\n        include: \"listStart\"\n      }, {\n        include: \"text\"\n      }],\n      \"indentedBlock\": [{\n        token: \"literal\",\n        regex: /^[\\s\\w].+$/,\n        next: \"indentedBlock\"\n      }, {\n        token: \"literal\",\n        regex: \"\",\n        next: \"start\"\n      }],\n      \"listingBlock\": [{\n        token: \"literal\",\n        regex: /^\\.{4,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"constant.numeric\",\n        regex: '<\\\\d+>'\n      }, {\n        token: \"literal\",\n        regex: '[^<]+'\n      }, {\n        token: \"literal\",\n        regex: '<'\n      }],\n      \"literalBlock\": [{\n        token: \"literal\",\n        regex: /^-{4,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"constant.numeric\",\n        regex: '<\\\\d+>'\n      }, {\n        token: \"literal\",\n        regex: '[^<]+'\n      }, {\n        token: \"literal\",\n        regex: '<'\n      }],\n      \"passthroughBlock\": [{\n        token: \"literal\",\n        regex: /^\\+{4,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"literal\",\n        regex: identifierRe + \"|\\\\d+\"\n      }, {\n        include: \"macros\"\n      }, {\n        token: \"literal\",\n        regex: \".\"\n      }],\n      \"smallPassthrough\": [{\n        token: \"literal\",\n        regex: /[+]{3,}/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"literal\",\n        regex: /^\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"literal\",\n        regex: identifierRe + \"|\\\\d+\"\n      }, {\n        include: \"macros\"\n      }],\n      \"commentBlock\": [{\n        token: \"doc.comment\",\n        regex: /^\\/{4,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"doc.comment\",\n        regex: '^.*$'\n      }],\n      \"tableBlock\": [{\n        token: \"tableBlock\",\n        regex: /^\\s*\\|={3,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"tableBlock\",\n        regex: /^\\s*!={3,}\\s*$/,\n        next: \"innerTableBlock\"\n      }, {\n        token: \"tableBlock\",\n        regex: /\\|/\n      }, {\n        include: \"text\",\n        noEscape: true\n      }],\n      \"innerTableBlock\": [{\n        token: \"tableBlock\",\n        regex: /^\\s*!={3,}\\s*$/,\n        next: \"tableBlock\"\n      }, {\n        token: \"tableBlock\",\n        regex: /^\\s*|={3,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"tableBlock\",\n        regex: /!/\n      }],\n      \"macros\": [{\n        token: \"macro\",\n        regex: /{[\\w\\-$]+}/\n      }, {\n        token: [\"text\", \"string\", \"text\", \"constant.character\", \"text\"],\n        regex: /({)([\\w\\-$]+)(:)?(.+)?(})/\n      }, {\n        token: [\"text\", \"markup.list.macro\", \"keyword\", \"string\"],\n        regex: /(\\w+)(footnote(?:ref)?::?)([^\\s\\[]+)?(\\[.*?\\])?/\n      }, {\n        token: [\"markup.list.macro\", \"keyword\", \"string\"],\n        regex: /([a-zA-Z\\-][\\w\\.\\/\\-]*::?)([^\\s\\[]+)(\\[.*?\\])?/\n      }, {\n        token: [\"markup.list.macro\", \"keyword\"],\n        regex: /([a-zA-Z\\-][\\w\\.\\/\\-]+::?)(\\[.*?\\])/\n      }, {\n        token: \"keyword\",\n        regex: /^:.+?:(?= |$)/\n      }],\n      \"quotes\": [{\n        token: \"string.italic\",\n        regex: /__[^_\\s].*?__/\n      }, {\n        token: \"string.italic\",\n        regex: quoteRule(\"_\")\n      }, {\n        token: \"keyword.bold\",\n        regex: /\\*\\*[^*\\s].*?\\*\\*/\n      }, {\n        token: \"keyword.bold\",\n        regex: quoteRule(\"\\\\*\")\n      }, {\n        token: \"literal\",\n        regex: quoteRule(\"\\\\+\")\n      }, {\n        token: \"literal\",\n        regex: /\\+\\+[^+\\s].*?\\+\\+/\n      }, {\n        token: \"literal\",\n        regex: /\\$\\$.+?\\$\\$/\n      }, {\n        token: \"literal\",\n        regex: quoteRule(\"`\")\n      }, {\n        token: \"keyword\",\n        regex: quoteRule(\"^\")\n      }, {\n        token: \"keyword\",\n        regex: quoteRule(\"~\")\n      }, {\n        token: \"keyword\",\n        regex: /##?/\n      }, {\n        token: \"keyword\",\n        regex: /(?:\\B|^)``|\\b''/\n      }]\n    };\n\n    function quoteRule(ch) {\n      var prefix = /\\w/.test(ch) ? \"\\\\b\" : \"(?:\\\\B|^)\";\n      return prefix + ch + \"[^\" + ch + \"].*?\" + ch + \"(?![\\\\w*])\";\n    }\n\n    var tokenMap = {\n      macro: \"constant.character\",\n      tableBlock: \"doc.comment\",\n      titleUnderline: \"markup.heading\",\n      singleLineTitle: \"markup.heading\",\n      pageBreak: \"string\",\n      option: \"string.regexp\",\n      otherBlock: \"markup.list\",\n      literal: \"support.function\",\n      optionalTitle: \"constant.numeric\",\n      escape: \"constant.language.escape\",\n      link: \"markup.underline.list\"\n    };\n\n    for (var state in this.$rules) {\n      var stateRules = this.$rules[state];\n\n      for (var i = stateRules.length; i--;) {\n        var rule = stateRules[i];\n\n        if (rule.include || typeof rule == \"string\") {\n          var args = [i, 1].concat(this.$rules[rule.include || rule]);\n\n          if (rule.noEscape) {\n            args = args.filter(function (x) {\n              return !x.next;\n            });\n          }\n\n          stateRules.splice.apply(stateRules, args);\n        } else if (rule.token in tokenMap) {\n          rule.token = tokenMap[rule.token];\n        }\n      }\n    }\n  };\n\n  oop.inherits(AsciidocHighlightRules, TextHighlightRules);\n  exports.AsciidocHighlightRules = AsciidocHighlightRules;\n});\nace.define(\"ace/mode/folding/asciidoc\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\n  var Range = require(\"../../range\").Range;\n\n  var FoldMode = exports.FoldMode = function () {};\n\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.foldingStartMarker = /^(?:\\|={10,}|[\\.\\/=\\-~^+]{4,}\\s*$|={1,5} )/;\n    this.singleLineHeadingRe = /^={1,5}(?=\\s+\\S)/;\n\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      if (!this.foldingStartMarker.test(line)) return \"\";\n\n      if (line[0] == \"=\") {\n        if (this.singleLineHeadingRe.test(line)) return \"start\";\n        if (session.getLine(row - 1).length != session.getLine(row).length) return \"\";\n        return \"start\";\n      }\n\n      if (session.bgTokenizer.getState(row) == \"dissallowDelimitedBlock\") return \"end\";\n      return \"start\";\n    };\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var startColumn = line.length;\n      var maxRow = session.getLength();\n      var startRow = row;\n      var endRow = row;\n      if (!line.match(this.foldingStartMarker)) return;\n      var token;\n\n      function getTokenType(row) {\n        token = session.getTokens(row)[0];\n        return token && token.type;\n      }\n\n      var levels = [\"=\", \"-\", \"~\", \"^\", \"+\"];\n      var heading = \"markup.heading\";\n      var singleLineHeadingRe = this.singleLineHeadingRe;\n\n      function getLevel() {\n        var match = token.value.match(singleLineHeadingRe);\n        if (match) return match[0].length;\n        var level = levels.indexOf(token.value[0]) + 1;\n\n        if (level == 1) {\n          if (session.getLine(row - 1).length != session.getLine(row).length) return Infinity;\n        }\n\n        return level;\n      }\n\n      if (getTokenType(row) == heading) {\n        var startHeadingLevel = getLevel();\n\n        while (++row < maxRow) {\n          if (getTokenType(row) != heading) continue;\n          var level = getLevel();\n          if (level <= startHeadingLevel) break;\n        }\n\n        var isSingleLineHeading = token && token.value.match(this.singleLineHeadingRe);\n        endRow = isSingleLineHeading ? row - 1 : row - 2;\n\n        if (endRow > startRow) {\n          while (endRow > startRow && (!getTokenType(endRow) || token.value[0] == \"[\")) {\n            endRow--;\n          }\n        }\n\n        if (endRow > startRow) {\n          var endColumn = session.getLine(endRow).length;\n          return new Range(startRow, startColumn, endRow, endColumn);\n        }\n      } else {\n        var state = session.bgTokenizer.getState(row);\n\n        if (state == \"dissallowDelimitedBlock\") {\n          while (row-- > 0) {\n            if (session.bgTokenizer.getState(row).lastIndexOf(\"Block\") == -1) break;\n          }\n\n          endRow = row + 1;\n\n          if (endRow < startRow) {\n            var endColumn = session.getLine(row).length;\n            return new Range(endRow, 5, startRow, startColumn - 5);\n          }\n        } else {\n          while (++row < maxRow) {\n            if (session.bgTokenizer.getState(row) == \"dissallowDelimitedBlock\") break;\n          }\n\n          endRow = row;\n\n          if (endRow > startRow) {\n            var endColumn = session.getLine(row).length;\n            return new Range(startRow, 5, endRow, endColumn - 5);\n          }\n        }\n      }\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/asciidoc\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/asciidoc_highlight_rules\", \"ace/mode/folding/asciidoc\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextMode = require(\"./text\").Mode;\n\n  var AsciidocHighlightRules = require(\"./asciidoc_highlight_rules\").AsciidocHighlightRules;\n\n  var AsciidocFoldMode = require(\"./folding/asciidoc\").FoldMode;\n\n  var Mode = function Mode() {\n    this.HighlightRules = AsciidocHighlightRules;\n    this.foldingRules = new AsciidocFoldMode();\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.type = \"text\";\n\n    this.getNextLineIndent = function (state, line, tab) {\n      if (state == \"listblock\") {\n        var match = /^((?:.+)?)([-+*][ ]+)/.exec(line);\n\n        if (match) {\n          return new Array(match[1].length + 1).join(\" \") + match[2];\n        } else {\n          return \"\";\n        }\n      } else {\n        return this.$getIndent(line);\n      }\n    };\n\n    this.$id = \"ace/mode/asciidoc\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n\n(function () {\n  ace.require([\"ace/mode/asciidoc\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}