{"ast":null,"code":"ace.define(\"ace/mode/doc_comment_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n  var DocCommentHighlightRules = function DocCommentHighlightRules() {\n    this.$rules = {\n      \"start\": [{\n        token: \"comment.doc.tag\",\n        regex: \"@[\\\\w\\\\d_]+\" // TODO: fix email addresses\n\n      }, DocCommentHighlightRules.getTagRule(), {\n        defaultToken: \"comment.doc\",\n        caseInsensitive: true\n      }]\n    };\n  };\n\n  oop.inherits(DocCommentHighlightRules, TextHighlightRules);\n\n  DocCommentHighlightRules.getTagRule = function (start) {\n    return {\n      token: \"comment.doc.tag.storage.type\",\n      regex: \"\\\\b(?:TODO|FIXME|XXX|HACK)\\\\b\"\n    };\n  };\n\n  DocCommentHighlightRules.getStartRule = function (start) {\n    return {\n      token: \"comment.doc\",\n      // doc comment\n      regex: \"\\\\/\\\\*(?=\\\\*)\",\n      next: start\n    };\n  };\n\n  DocCommentHighlightRules.getEndRule = function (start) {\n    return {\n      token: \"comment.doc\",\n      // closing comment\n      regex: \"\\\\*\\\\/\",\n      next: start\n    };\n  };\n\n  exports.DocCommentHighlightRules = DocCommentHighlightRules;\n});\nace.define(\"ace/mode/json_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n  var JsonHighlightRules = function JsonHighlightRules() {\n    this.$rules = {\n      \"start\": [{\n        token: \"variable\",\n        // single line\n        regex: '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]\\\\s*(?=:)'\n      }, {\n        token: \"string\",\n        // single line\n        regex: '\"',\n        next: \"string\"\n      }, {\n        token: \"constant.numeric\",\n        // hex\n        regex: \"0[xX][0-9a-fA-F]+\\\\b\"\n      }, {\n        token: \"constant.numeric\",\n        // float\n        regex: \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n      }, {\n        token: \"constant.language.boolean\",\n        regex: \"(?:true|false)\\\\b\"\n      }, {\n        token: \"text\",\n        // single quoted strings are not allowed\n        regex: \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n      }, {\n        token: \"comment\",\n        // comments are not allowed, but who cares?\n        regex: \"\\\\/\\\\/.*$\"\n      }, {\n        token: \"comment.start\",\n        // comments are not allowed, but who cares?\n        regex: \"\\\\/\\\\*\",\n        next: \"comment\"\n      }, {\n        token: \"paren.lparen\",\n        regex: \"[[({]\"\n      }, {\n        token: \"paren.rparen\",\n        regex: \"[\\\\])}]\"\n      }, {\n        token: \"text\",\n        regex: \"\\\\s+\"\n      }],\n      \"string\": [{\n        token: \"constant.language.escape\",\n        regex: /\\\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|[\"\\\\\\/bfnrt])/\n      }, {\n        token: \"string\",\n        regex: '\"|$',\n        next: \"start\"\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"comment\": [{\n        token: \"comment.end\",\n        // comments are not allowed, but who cares?\n        regex: \"\\\\*\\\\/\",\n        next: \"start\"\n      }, {\n        defaultToken: \"comment\"\n      }]\n    };\n  };\n\n  oop.inherits(JsonHighlightRules, TextHighlightRules);\n  exports.JsonHighlightRules = JsonHighlightRules;\n});\nace.define(\"ace/mode/redshift_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/lib/lang\", \"ace/mode/doc_comment_highlight_rules\", \"ace/mode/text_highlight_rules\", \"ace/mode/json_highlight_rules\"], function (require, exports, module) {\n  var oop = require(\"../lib/oop\");\n\n  var lang = require(\"../lib/lang\");\n\n  var DocCommentHighlightRules = require(\"./doc_comment_highlight_rules\").DocCommentHighlightRules;\n\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n  var JsonHighlightRules = require(\"./json_highlight_rules\").JsonHighlightRules;\n\n  var RedshiftHighlightRules = function RedshiftHighlightRules() {\n    var keywords = \"aes128|aes256|all|allowoverwrite|analyse|analyze|and|any|array|as|asc|authorization|backup|\" + \"between|binary|blanksasnull|both|bytedict|bzip2|case|cast|check|collate|column|constraint|create|credentials|\" + \"cross|current_date|current_time|current_timestamp|current_user|current_user_id|default|deferrable|deflate|defrag|delta|\" + \"delta32k|desc|disable|distinct|do|else|emptyasnull|enable|encode|encrypt|encryption|end|except|explicit|false|for|foreign|\" + \"freeze|from|full|globaldict256|globaldict64k|grant|group|gzip|having|identity|ignore|ilike|in|initially|inner|intersect|into|is|\" + \"isnull|join|leading|left|like|limit|localtime|localtimestamp|lun|luns|lzo|lzop|minus|mostly13|mostly32|mostly8|natural|new|not|notnull|\" + \"null|nulls|off|offline|offset|old|on|only|open|or|order|outer|overlaps|parallel|partition|percent|permissions|placing|primary|raw|readratio|\" + \"recover|references|rejectlog|resort|restore|right|select|session_user|similar|some|sysdate|system|table|tag|tdes|text255|text32k|then|timestamp|\" + \"to|top|trailing|true|truncatecolumns|union|unique|user|using|verbose|wallet|when|where|with|without\";\n    var builtinFunctions = \"current_schema|current_schemas|has_database_privilege|has_schema_privilege|has_table_privilege|age|current_time|current_timestamp|localtime|\" + \"isfinite|now|ascii|get_bit|get_byte|octet_length|set_bit|set_byte|to_ascii|avg|count|listagg|max|min|stddev_samp|stddev_pop|sum|var_samp|var_pop|\" + \"bit_and|bit_or|bool_and|bool_or|avg|count|cume_dist|dense_rank|first_value|last_value|lag|lead|listagg|max|median|min|nth_value|ntile|percent_rank|\" + \"percentile_cont|percentile_disc|rank|ratio_to_report|row_number|case|coalesce|decode|greatest|least|nvl|nvl2|nullif|add_months|age|convert_timezone|\" + \"current_date|timeofday|current_time|current_timestamp|date_cmp|date_cmp_timestamp|date_part_year|dateadd|datediff|date_part|date_trunc|extract|getdate|\" + \"interval_cmp|isfinite|last_day|localtime|localtimestamp|months_between|next_day|now|sysdate|timestamp_cmp|timestamp_cmp_date|trunc|abs|acos|asin|atan|\" + \"atan2|cbrt|ceiling|ceil|checksum|cos|cot|degrees|dexp|dlog1|dlog10|exp|floor|ln|log|mod|pi|power|radians|random|round|sin|sign|sqrt|tan|trunc|ascii|\" + \"bpcharcmp|btrim|bttext_pattern_cmp|char_length|character_length|charindex|chr|concat|crc32|func_sha1|get_bit|get_byte|initcap|left|right|len|length|\" + \"lower|lpad|rpad|ltrim|md5|octet_length|position|quote_ident|quote_literal|regexp_count|regexp_instr|regexp_replace|regexp_substr|repeat|replace|replicate|\" + \"reverse|rtrim|set_bit|set_byte|split_part|strpos|strtol|substring|textlen|to_ascii|to_hex|translate|trim|upper|json_array_length|json_extract_array_element_text|\" + \"json_extract_path_text|cast|convert|to_char|to_date|to_number|current_database|current_schema|current_schemas|current_user|current_user_id|has_database_privilege|\" + \"has_schema_privilege|has_table_privilege|pg_backend_pid|pg_last_copy_count|pg_last_copy_id|pg_last_query_id|pg_last_unload_count|session_user|slice_num|user|version\";\n    var keywordMapper = this.createKeywordMapper({\n      \"support.function\": builtinFunctions,\n      \"keyword\": keywords\n    }, \"identifier\", true);\n    var sqlRules = [{\n      token: \"string\",\n      // single line string -- assume dollar strings if multi-line for now\n      regex: \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n    }, {\n      token: \"variable.language\",\n      // pg identifier\n      regex: '\".*?\"'\n    }, {\n      token: \"constant.numeric\",\n      // float\n      regex: \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n    }, {\n      token: keywordMapper,\n      regex: \"[a-zA-Z_][a-zA-Z0-9_$]*\\\\b\" // TODO - Unicode in identifiers\n\n    }, {\n      token: \"keyword.operator\",\n      regex: \"!|!!|!~|!~\\\\*|!~~|!~~\\\\*|#|##|#<|#<=|#<>|#=|#>|#>=|%|\\\\&|\\\\&\\\\&|\\\\&<|\\\\&<\\\\||\\\\&>|\\\\*|\\\\+|\" + \"\\\\-|/|<|<#>|<\\\\->|<<|<<=|<<\\\\||<=|<>|<\\\\?>|<@|<\\\\^|=|>|>=|>>|>>=|>\\\\^|\\\\?#|\\\\?\\\\-|\\\\?\\\\-\\\\||\" + \"\\\\?\\\\||\\\\?\\\\|\\\\||@|@\\\\-@|@>|@@|@@@|\\\\^|\\\\||\\\\|\\\\&>|\\\\|/|\\\\|>>|\\\\|\\\\||\\\\|\\\\|/|~|~\\\\*|~<=~|~<~|\" + \"~=|~>=~|~>~|~~|~~\\\\*\"\n    }, {\n      token: \"paren.lparen\",\n      regex: \"[\\\\(]\"\n    }, {\n      token: \"paren.rparen\",\n      regex: \"[\\\\)]\"\n    }, {\n      token: \"text\",\n      regex: \"\\\\s+\"\n    }];\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \"--.*$\"\n      }, DocCommentHighlightRules.getStartRule(\"doc-start\"), {\n        token: \"comment\",\n        // multi-line comment\n        regex: \"\\\\/\\\\*\",\n        next: \"comment\"\n      }, {\n        token: \"keyword.statementBegin\",\n        regex: \"^[a-zA-Z]+\",\n        // Could enumerate starting keywords but this allows things to work when new statements are added.\n        next: \"statement\"\n      }, {\n        token: \"support.buildin\",\n        // psql directive\n        regex: \"^\\\\\\\\[\\\\S]+.*$\"\n      }],\n      \"statement\": [{\n        token: \"comment\",\n        regex: \"--.*$\"\n      }, {\n        token: \"comment\",\n        // multi-line comment\n        regex: \"\\\\/\\\\*\",\n        next: \"commentStatement\"\n      }, {\n        token: \"statementEnd\",\n        regex: \";\",\n        next: \"start\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\$json\\\\$\",\n        next: \"json-start\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\$[\\\\w_0-9]*\\\\$$\",\n        // dollar quote at the end of a line\n        next: \"dollarSql\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\$[\\\\w_0-9]*\\\\$\",\n        next: \"dollarStatementString\"\n      }].concat(sqlRules),\n      \"dollarSql\": [{\n        token: \"comment\",\n        regex: \"--.*$\"\n      }, {\n        token: \"comment\",\n        // multi-line comment\n        regex: \"\\\\/\\\\*\",\n        next: \"commentDollarSql\"\n      }, {\n        token: \"string\",\n        // end quoting with dollar at the start of a line\n        regex: \"^\\\\$[\\\\w_0-9]*\\\\$\",\n        next: \"statement\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\$[\\\\w_0-9]*\\\\$\",\n        next: \"dollarSqlString\"\n      }].concat(sqlRules),\n      \"comment\": [{\n        token: \"comment\",\n        // closing comment\n        regex: \".*?\\\\*\\\\/\",\n        next: \"start\"\n      }, {\n        token: \"comment\",\n        // comment spanning whole line\n        regex: \".+\"\n      }],\n      \"commentStatement\": [{\n        token: \"comment\",\n        // closing comment\n        regex: \".*?\\\\*\\\\/\",\n        next: \"statement\"\n      }, {\n        token: \"comment\",\n        // comment spanning whole line\n        regex: \".+\"\n      }],\n      \"commentDollarSql\": [{\n        token: \"comment\",\n        // closing comment\n        regex: \".*?\\\\*\\\\/\",\n        next: \"dollarSql\"\n      }, {\n        token: \"comment\",\n        // comment spanning whole line\n        regex: \".+\"\n      }],\n      \"dollarStatementString\": [{\n        token: \"string\",\n        // closing dollarstring\n        regex: \".*?\\\\$[\\\\w_0-9]*\\\\$\",\n        next: \"statement\"\n      }, {\n        token: \"string\",\n        // dollarstring spanning whole line\n        regex: \".+\"\n      }],\n      \"dollarSqlString\": [{\n        token: \"string\",\n        // closing dollarstring\n        regex: \".*?\\\\$[\\\\w_0-9]*\\\\$\",\n        next: \"dollarSql\"\n      }, {\n        token: \"string\",\n        // dollarstring spanning whole line\n        regex: \".+\"\n      }]\n    };\n    this.embedRules(DocCommentHighlightRules, \"doc-\", [DocCommentHighlightRules.getEndRule(\"start\")]);\n    this.embedRules(JsonHighlightRules, \"json-\", [{\n      token: \"string\",\n      regex: \"\\\\$json\\\\$\",\n      next: \"statement\"\n    }]);\n  };\n\n  oop.inherits(RedshiftHighlightRules, TextHighlightRules);\n  exports.RedshiftHighlightRules = RedshiftHighlightRules;\n});\nace.define(\"ace/mode/redshift\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/redshift_highlight_rules\", \"ace/range\"], function (require, exports, module) {\n  var oop = require(\"../lib/oop\");\n\n  var TextMode = require(\"../mode/text\").Mode;\n\n  var RedshiftHighlightRules = require(\"./redshift_highlight_rules\").RedshiftHighlightRules;\n\n  var Range = require(\"../range\").Range;\n\n  var Mode = function Mode() {\n    this.HighlightRules = RedshiftHighlightRules;\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"--\";\n    this.blockComment = {\n      start: \"/*\",\n      end: \"*/\"\n    };\n\n    this.getNextLineIndent = function (state, line, tab) {\n      if (state == \"start\" || state == \"keyword.statementEnd\") {\n        return \"\";\n      } else {\n        return this.$getIndent(line); // Keep whatever indent the previous line has\n      }\n    };\n\n    this.$id = \"ace/mode/redshift\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n\n(function () {\n  ace.require([\"ace/mode/redshift\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}