{"ast":null,"code":"ace.define(\"ace/mode/c9search_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/lib/lang\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var lang = require(\"../lib/lang\");\n\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n  function safeCreateRegexp(source, flag) {\n    try {\n      return new RegExp(source, flag);\n    } catch (e) {}\n  }\n\n  var C9SearchHighlightRules = function C9SearchHighlightRules() {\n    this.$rules = {\n      \"start\": [{\n        tokenNames: [\"c9searchresults.constant.numeric\", \"c9searchresults.text\", \"c9searchresults.text\", \"c9searchresults.keyword\"],\n        regex: /(^\\s+[0-9]+)(:)(\\d*\\s?)([^\\r\\n]+)/,\n        onMatch: function onMatch(val, state, stack) {\n          var values = this.splitRegex.exec(val);\n          var types = this.tokenNames;\n          var tokens = [{\n            type: types[0],\n            value: values[1]\n          }, {\n            type: types[1],\n            value: values[2]\n          }];\n\n          if (values[3]) {\n            if (values[3] == \" \") tokens[1] = {\n              type: types[1],\n              value: values[2] + \" \"\n            };else tokens.push({\n              type: types[1],\n              value: values[3]\n            });\n          }\n\n          var regex = stack[1];\n          var str = values[4];\n          var m;\n          var last = 0;\n\n          if (regex && regex.exec) {\n            regex.lastIndex = 0;\n\n            while (m = regex.exec(str)) {\n              var skipped = str.substring(last, m.index);\n              last = regex.lastIndex;\n              if (skipped) tokens.push({\n                type: types[2],\n                value: skipped\n              });\n              if (m[0]) tokens.push({\n                type: types[3],\n                value: m[0]\n              });else if (!skipped) break;\n            }\n          }\n\n          if (last < str.length) tokens.push({\n            type: types[2],\n            value: str.substr(last)\n          });\n          return tokens;\n        }\n      }, {\n        regex: \"^Searching for [^\\\\r\\\\n]*$\",\n        onMatch: function onMatch(val, state, stack) {\n          var parts = val.split(\"\\x01\");\n          if (parts.length < 3) return \"text\";\n          var options, search;\n          var i = 0;\n          var tokens = [{\n            value: parts[i++] + \"'\",\n            type: \"text\"\n          }, {\n            value: search = parts[i++],\n            type: \"text\" // \"c9searchresults.keyword\"\n\n          }, {\n            value: \"'\" + parts[i++],\n            type: \"text\"\n          }];\n\n          if (parts[2] !== \" in\") {\n            tokens.push({\n              value: \"'\" + parts[i++] + \"'\",\n              type: \"text\"\n            }, {\n              value: parts[i++],\n              type: \"text\"\n            });\n          }\n\n          tokens.push({\n            value: \" \" + parts[i++] + \" \",\n            type: \"text\"\n          });\n\n          if (parts[i + 1]) {\n            options = parts[i + 1];\n            tokens.push({\n              value: \"(\" + parts[i + 1] + \")\",\n              type: \"text\"\n            });\n            i += 1;\n          } else {\n            i -= 1;\n          }\n\n          while (i++ < parts.length) {\n            parts[i] && tokens.push({\n              value: parts[i],\n              type: \"text\"\n            });\n          }\n\n          if (search) {\n            if (!/regex/.test(options)) search = lang.escapeRegExp(search);\n            if (/whole/.test(options)) search = \"\\\\b\" + search + \"\\\\b\";\n          }\n\n          var regex = search && safeCreateRegexp(\"(\" + search + \")\", / sensitive/.test(options) ? \"g\" : \"ig\");\n\n          if (regex) {\n            stack[0] = state;\n            stack[1] = regex;\n          }\n\n          return tokens;\n        }\n      }, {\n        regex: \"^(?=Found \\\\d+ matches)\",\n        token: \"text\",\n        next: \"numbers\"\n      }, {\n        token: \"string\",\n        // single line\n        regex: \"^\\\\S:?[^:]+\",\n        next: \"numbers\"\n      }],\n      numbers: [{\n        regex: \"\\\\d+\",\n        token: \"constant.numeric\"\n      }, {\n        regex: \"$\",\n        token: \"text\",\n        next: \"start\"\n      }]\n    };\n    this.normalizeRules();\n  };\n\n  oop.inherits(C9SearchHighlightRules, TextHighlightRules);\n  exports.C9SearchHighlightRules = C9SearchHighlightRules;\n});\nace.define(\"ace/mode/matching_brace_outdent\", [\"require\", \"exports\", \"module\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n\n  var MatchingBraceOutdent = function MatchingBraceOutdent() {};\n\n  (function () {\n    this.checkOutdent = function (line, input) {\n      if (!/^\\s+$/.test(line)) return false;\n      return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function (doc, row) {\n      var line = doc.getLine(row);\n      var match = line.match(/^(\\s*\\})/);\n      if (!match) return 0;\n      var column = match[1].length;\n      var openBracePos = doc.findMatchingBracket({\n        row: row,\n        column: column\n      });\n      if (!openBracePos || openBracePos.row == row) return 0;\n      var indent = this.$getIndent(doc.getLine(openBracePos.row));\n      doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n\n    this.$getIndent = function (line) {\n      return line.match(/^\\s*/)[0];\n    };\n  }).call(MatchingBraceOutdent.prototype);\n  exports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\nace.define(\"ace/mode/folding/c9search\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/range\", \"ace/mode/folding/fold_mode\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n\n  var Range = require(\"../../range\").Range;\n\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\n  var FoldMode = exports.FoldMode = function () {};\n\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.foldingStartMarker = /^(\\S.*:|Searching for.*)$/;\n    this.foldingStopMarker = /^(\\s+|Found.*)$/;\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var lines = session.doc.getAllLines(row);\n      var line = lines[row];\n      var level1 = /^(Found.*|Searching for.*)$/;\n      var level2 = /^(\\S.*:|\\s*)$/;\n      var re = level1.test(line) ? level1 : level2;\n      var startRow = row;\n      var endRow = row;\n\n      if (this.foldingStartMarker.test(line)) {\n        for (var i = row + 1, l = session.getLength(); i < l; i++) {\n          if (re.test(lines[i])) break;\n        }\n\n        endRow = i;\n      } else if (this.foldingStopMarker.test(line)) {\n        for (var i = row - 1; i >= 0; i--) {\n          line = lines[i];\n          if (re.test(line)) break;\n        }\n\n        startRow = i;\n      }\n\n      if (startRow != endRow) {\n        var col = line.length;\n        if (re === level1) col = line.search(/\\(Found[^)]+\\)$|$/);\n        return new Range(startRow, col, endRow, 0);\n      }\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/c9search\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/c9search_highlight_rules\", \"ace/mode/matching_brace_outdent\", \"ace/mode/folding/c9search\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextMode = require(\"./text\").Mode;\n\n  var C9SearchHighlightRules = require(\"./c9search_highlight_rules\").C9SearchHighlightRules;\n\n  var MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\n\n  var C9StyleFoldMode = require(\"./folding/c9search\").FoldMode;\n\n  var Mode = function Mode() {\n    this.HighlightRules = C9SearchHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.foldingRules = new C9StyleFoldMode();\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.getNextLineIndent = function (state, line, tab) {\n      var indent = this.$getIndent(line);\n      return indent;\n    };\n\n    this.checkOutdent = function (state, line, input) {\n      return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function (state, doc, row) {\n      this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.$id = \"ace/mode/c9search\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n\n(function () {\n  ace.require([\"ace/mode/c9search\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}