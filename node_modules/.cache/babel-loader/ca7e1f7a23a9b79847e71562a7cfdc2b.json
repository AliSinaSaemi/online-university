{"ast":null,"code":"ace.define(\"ace/mode/elixir_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n  var ElixirHighlightRules = function ElixirHighlightRules() {\n    this.$rules = {\n      start: [{\n        token: ['meta.module.elixir', 'keyword.control.module.elixir', 'meta.module.elixir', 'entity.name.type.module.elixir'],\n        regex: '^(\\\\s*)(defmodule)(\\\\s+)((?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*[A-Z]\\\\w*)'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc (?:~[a-z])?\"\"\"',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc ~[A-Z]\"\"\"',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc (?:~[a-z])?\\'\\'\\'',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc ~[A-Z]\\'\\'\\'',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.false',\n        regex: '@(?:module|type)?doc false',\n        comment: '@doc false is treated as documentation'\n      }, {\n        token: 'comment.documentation.string',\n        regex: '@(?:module|type)?doc \"',\n        push: [{\n          token: 'comment.documentation.string',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.string'\n        }],\n        comment: '@doc with string is treated as documentation'\n      }, {\n        token: 'keyword.control.elixir',\n        regex: '\\\\b(?:do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\.)\\\\b(do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])'\n      }, {\n        token: 'keyword.operator.elixir',\n        regex: '\\\\b(?:and|not|or|when|xor|in|inlist|inbits)\\\\b',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\.)\\\\b(and|not|or|when|xor|in|inlist|inbits)\\\\b',\n        comment: ' as above, just doesn\\'t need a \\'end\\' and does a logic operation'\n      }, {\n        token: 'constant.language.elixir',\n        regex: '\\\\b(?:nil|true|false)\\\\b(?![?!])'\n      }, {\n        token: 'variable.language.elixir',\n        regex: '\\\\b__(?:CALLER|ENV|MODULE|DIR)__\\\\b(?![?!])'\n      }, {\n        token: ['punctuation.definition.variable.elixir', 'variable.other.readwrite.module.elixir'],\n        regex: '(@)([a-zA-Z_]\\\\w*)'\n      }, {\n        token: ['punctuation.definition.variable.elixir', 'variable.other.anonymous.elixir'],\n        regex: '(&)(\\\\d*)'\n      }, {\n        token: 'variable.other.constant.elixir',\n        regex: '\\\\b[A-Z]\\\\w*\\\\b'\n      }, {\n        token: 'constant.numeric.elixir',\n        regex: '\\\\b(?:0x[\\\\da-fA-F](?:_?[\\\\da-fA-F])*|\\\\d(?:_?\\\\d)*(?:\\\\.(?![^[:space:][:digit:]])(?:_?\\\\d)*)?(?:[eE][-+]?\\\\d(?:_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '\\\\b(0x\\\\h(?>_?\\\\h)*|\\\\d(?>_?\\\\d)*(\\\\.(?![^[:space:][:digit:]])(?>_?\\\\d)*)?([eE][-+]?\\\\d(?>_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b'\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: ':\\'',\n        push: [{\n          token: 'punctuation.definition.constant.elixir',\n          regex: '\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'constant.other.symbol.single-quoted.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: ':\"',\n        push: [{\n          token: 'punctuation.definition.constant.elixir',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'constant.other.symbol.double-quoted.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '(?:\\'\\'\\')',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>\\'\\'\\')',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'support.function.variable.quoted.single.heredoc.elixir'\n        }],\n        comment: 'Single-quoted heredocs'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '\\'',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'support.function.variable.quoted.single.elixir'\n        }],\n        comment: 'single quoted string (allows for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '(?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.heredoc.elixir'\n        }],\n        comment: 'Double-quoted heredocs'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '\"',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.elixir'\n        }],\n        comment: 'double quoted string (allows for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z](?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '~[a-z](?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.heredoc.elixir'\n        }],\n        comment: 'Double-quoted heredocs sigils'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\{',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\}[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\[',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\][a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\<',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\>[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\(',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\)[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z][^\\\\w]',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '[^\\\\w][a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z](?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '~[A-Z](?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'Double-quoted heredocs sigils'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\{',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\}[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\[',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\][a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\<',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\>[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\(',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\)[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z][^\\\\w]',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '[^\\\\w][a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: ['punctuation.definition.constant.elixir', 'constant.other.symbol.elixir'],\n        regex: '(:)([a-zA-Z_][\\\\w@]*(?:[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(?:\\\\^\\\\^)?)',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!:)(:)(?>[a-zA-Z_][\\\\w@]*(?>[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(\\\\^\\\\^)?)',\n        comment: 'symbols'\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: '(?:[a-zA-Z_][\\\\w@]*(?:[?!])?):(?!:)',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>[a-zA-Z_][\\\\w@]*(?>[?!])?)(:)(?!:)',\n        comment: 'symbols'\n      }, {\n        token: ['punctuation.definition.comment.elixir', 'comment.line.number-sign.elixir'],\n        regex: '(#)(.*)'\n      }, {\n        token: 'constant.numeric.elixir',\n        regex: '\\\\?(?:\\\\\\\\(?:x[\\\\da-fA-F]{1,2}(?![\\\\da-fA-F])\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\w)\\\\?(\\\\\\\\(x\\\\h{1,2}(?!\\\\h)\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n        comment: '\\n\\t\\t\\tmatches questionmark-letters.\\n\\n\\t\\t\\texamples (1st alternation = hex):\\n\\t\\t\\t?\\\\x1     ?\\\\x61\\n\\n\\t\\t\\texamples (2rd alternation = escaped):\\n\\t\\t\\t?\\\\n      ?\\\\b\\n\\n\\t\\t\\texamples (3rd alternation = normal):\\n\\t\\t\\t?a       ?A       ?0 \\n\\t\\t\\t?*       ?\"       ?( \\n\\t\\t\\t?.       ?#\\n\\t\\t\\t\\n\\t\\t\\tthe negative lookbehind prevents against matching\\n\\t\\t\\tp(42.tainted?)\\n\\t\\t\\t'\n      }, {\n        token: 'keyword.operator.assignment.augmented.elixir',\n        regex: '\\\\+=|\\\\-=|\\\\|\\\\|=|~=|&&='\n      }, {\n        token: 'keyword.operator.comparison.elixir',\n        regex: '===?|!==?|<=?|>=?'\n      }, {\n        token: 'keyword.operator.bitwise.elixir',\n        regex: '\\\\|{3}|&{3}|\\\\^{3}|<{3}|>{3}|~{3}'\n      }, {\n        token: 'keyword.operator.logical.elixir',\n        regex: '!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b',\n        originalRegex: '(?<=[ \\\\t])!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b'\n      }, {\n        token: 'keyword.operator.arithmetic.elixir',\n        regex: '\\\\*|\\\\+|\\\\-|/'\n      }, {\n        token: 'keyword.operator.other.elixir',\n        regex: '\\\\||\\\\+\\\\+|\\\\-\\\\-|\\\\*\\\\*|\\\\\\\\\\\\\\\\|\\\\<\\\\-|\\\\<\\\\>|\\\\<\\\\<|\\\\>\\\\>|\\\\:\\\\:|\\\\.\\\\.|\\\\|>|~|=>'\n      }, {\n        token: 'keyword.operator.assignment.elixir',\n        regex: '='\n      }, {\n        token: 'punctuation.separator.other.elixir',\n        regex: ':'\n      }, {\n        token: 'punctuation.separator.statement.elixir',\n        regex: '\\\\;'\n      }, {\n        token: 'punctuation.separator.object.elixir',\n        regex: ','\n      }, {\n        token: 'punctuation.separator.method.elixir',\n        regex: '\\\\.'\n      }, {\n        token: 'punctuation.section.scope.elixir',\n        regex: '\\\\{|\\\\}'\n      }, {\n        token: 'punctuation.section.array.elixir',\n        regex: '\\\\[|\\\\]'\n      }, {\n        token: 'punctuation.section.function.elixir',\n        regex: '\\\\(|\\\\)'\n      }],\n      '#escaped_char': [{\n        token: 'constant.character.escape.elixir',\n        regex: '\\\\\\\\(?:x[\\\\da-fA-F]{1,2}|.)'\n      }],\n      '#interpolated_elixir': [{\n        token: ['source.elixir.embedded.source', 'source.elixir.embedded.source.empty'],\n        regex: '(#\\\\{)(\\\\})'\n      }, {\n        todo: {\n          token: 'punctuation.section.embedded.elixir',\n          regex: '#\\\\{',\n          push: [{\n            token: 'punctuation.section.embedded.elixir',\n            regex: '\\\\}',\n            next: 'pop'\n          }, {\n            include: '#nest_curly_and_self'\n          }, {\n            include: '$self'\n          }, {\n            defaultToken: 'source.elixir.embedded.source'\n          }]\n        }\n      }],\n      '#nest_curly_and_self': [{\n        token: 'punctuation.section.scope.elixir',\n        regex: '\\\\{',\n        push: [{\n          token: 'punctuation.section.scope.elixir',\n          regex: '\\\\}',\n          next: 'pop'\n        }, {\n          include: '#nest_curly_and_self'\n        }]\n      }, {\n        include: '$self'\n      }],\n      '#regex_sub': [{\n        include: '#interpolated_elixir'\n      }, {\n        include: '#escaped_char'\n      }, {\n        token: ['punctuation.definition.arbitrary-repitition.elixir', 'string.regexp.arbitrary-repitition.elixir', 'string.regexp.arbitrary-repitition.elixir', 'punctuation.definition.arbitrary-repitition.elixir'],\n        regex: '(\\\\{)(\\\\d+)((?:,\\\\d+)?)(\\\\})'\n      }, {\n        token: 'punctuation.definition.character-class.elixir',\n        regex: '\\\\[(?:\\\\^?\\\\])?',\n        push: [{\n          token: 'punctuation.definition.character-class.elixir',\n          regex: '\\\\]',\n          next: 'pop'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.regexp.character-class.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.group.elixir',\n        regex: '\\\\(',\n        push: [{\n          token: 'punctuation.definition.group.elixir',\n          regex: '\\\\)',\n          next: 'pop'\n        }, {\n          include: '#regex_sub'\n        }, {\n          defaultToken: 'string.regexp.group.elixir'\n        }]\n      }, {\n        token: ['punctuation.definition.comment.elixir', 'comment.line.number-sign.elixir'],\n        regex: '(?:^|\\\\s)(#)(\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x00-\\\\x7F]]*$)',\n        originalRegex: '(?<=^|\\\\s)(#)\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x{00}-\\\\x{7F}]]*$',\n        comment: 'We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.'\n      }]\n    };\n    this.normalizeRules();\n  };\n\n  ElixirHighlightRules.metaData = {\n    comment: 'Textmate bundle for Elixir Programming Language.',\n    fileTypes: ['ex', 'exs'],\n    firstLineMatch: '^#!/.*\\\\belixir',\n    foldingStartMarker: '(after|else|catch|rescue|\\\\-\\\\>|\\\\{|\\\\[|do)\\\\s*$',\n    foldingStopMarker: '^\\\\s*((\\\\}|\\\\]|after|else|catch|rescue)\\\\s*$|end\\\\b)',\n    keyEquivalent: '^~E',\n    name: 'Elixir',\n    scopeName: 'source.elixir'\n  };\n  oop.inherits(ElixirHighlightRules, TextHighlightRules);\n  exports.ElixirHighlightRules = ElixirHighlightRules;\n});\nace.define(\"ace/mode/folding/coffee\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\n  var Range = require(\"../../range\").Range;\n\n  var FoldMode = exports.FoldMode = function () {};\n\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var range = this.indentationBlock(session, row);\n      if (range) return range;\n      var re = /\\S/;\n      var line = session.getLine(row);\n      var startLevel = line.search(re);\n      if (startLevel == -1 || line[startLevel] != \"#\") return;\n      var startColumn = line.length;\n      var maxRow = session.getLength();\n      var startRow = row;\n      var endRow = row;\n\n      while (++row < maxRow) {\n        line = session.getLine(row);\n        var level = line.search(re);\n        if (level == -1) continue;\n        if (line[level] != \"#\") break;\n        endRow = row;\n      }\n\n      if (endRow > startRow) {\n        var endColumn = session.getLine(endRow).length;\n        return new Range(startRow, startColumn, endRow, endColumn);\n      }\n    };\n\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var indent = line.search(/\\S/);\n      var next = session.getLine(row + 1);\n      var prev = session.getLine(row - 1);\n      var prevIndent = prev.search(/\\S/);\n      var nextIndent = next.search(/\\S/);\n\n      if (indent == -1) {\n        session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? \"start\" : \"\";\n        return \"\";\n      }\n\n      if (prevIndent == -1) {\n        if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n          session.foldWidgets[row - 1] = \"\";\n          session.foldWidgets[row + 1] = \"\";\n          return \"start\";\n        }\n      } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n        if (session.getLine(row - 2).search(/\\S/) == -1) {\n          session.foldWidgets[row - 1] = \"start\";\n          session.foldWidgets[row + 1] = \"\";\n          return \"\";\n        }\n      }\n\n      if (prevIndent != -1 && prevIndent < indent) session.foldWidgets[row - 1] = \"start\";else session.foldWidgets[row - 1] = \"\";\n      if (indent < nextIndent) return \"start\";else return \"\";\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/elixir\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/elixir_highlight_rules\", \"ace/mode/folding/coffee\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextMode = require(\"./text\").Mode;\n\n  var ElixirHighlightRules = require(\"./elixir_highlight_rules\").ElixirHighlightRules;\n\n  var FoldMode = require(\"./folding/coffee\").FoldMode;\n\n  var Mode = function Mode() {\n    this.HighlightRules = ElixirHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"#\";\n    this.$id = \"ace/mode/elixir\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n\n(function () {\n  ace.require([\"ace/mode/elixir\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}